# Brain and Mind 2021
# Introduction to Statistics and R
#------CLASS ONE-----
#Для начала познакомимся с RStudio. Тут есть скрипт, консоль, среда и вкладка с графиками и документацией (Шишков, прости, я буду сбиваться и готовить "хэлпом").
"Это команда, она исполняется (нажатием на Ctrl+Enter или Cmd+Enter)"
# Комментарии не исполняются
# Если у команды есть результат, то он покажется в консоли:
2+2
# С одним исключением: если мы запишем его в переменную. Тогда оно появится в среде!
res <- 2+2
# Предыдущая строка состоит из трёх элементов: имени переменной (оно может быть любым, но избегайте использовать имена функций), оператора присвоения (стрелочки) и того, что мы хотим в переменную "положить".
# Если мы положили что-нибудь в переменную, то дальше мы можем получить содержимое, обратившись к имени переменной:
res
# Если мы запишем что-нибудь новое в переменную с таким же именем, то "сотрём" старое:
res <- 2+4
res # Результат операции 2+2 потерян навечно

# Что можно положить в переменную?
# Строку (= текст)
vasiliy <- "Василий"
# Число
num <- 2
# Логическую переменную (TRUE или FALSE)
tf <- TRUE

# И некоторые другие штуки, про которые мы сегодня говорить не будем

# Всё это - типы данных.

# С разными типами данных можно осуществлять разные операции:
2 + 3
2*3
'a'+'b'
'a'*'b'
TRUE + TRUE
FALSE + TRUE
FALSE + FALSE

# Кроме арифметических, есть ещё операции сравнения:

"a" == "b" # Обратите внимание, двойное равно!

2 < 3

# Базовая структура данных в R это вектор - набор элементов одного типа, например, только чисел или только строк. Вектор создаётся с помощью функции c() (c for combine):
?c
vec <- c(4, 5, 3, 2, 2, 1) 

vec

# c числовыми векторами можно осуществлять самые разные преобразования. 

#арифметические операции
vec*2
vec*c(1,2,3,4) #что значит этот ворнинг?
vec-5
vec^2
vec/2

#операции сравнения
vec<=1
vec!=1
vec==1

#Обратите внимание - очень частая ошибка, vec=1 сделает vec равным единице, а не проверит, действительно ли vec ей равен.

vec2 <- vec>2 | vec<2

1 %in% vec

c(1,2,7) %in% vec
c(1,2,7) !%in% vec
# Ошибка! надо так:
!(c(1,2,7) %in% vec)
# Потому что:
!c(TRUE, FALSE)

# Так как TRUE хранится как 1, а FALSE как 0, то мы можем посчитать количество TRUE в вектора, просто посчитав его сумму

tf <- c(TRUE, FALSE, TRUE, TRUE)
sum(tf)

# Элемент вектора можно "достать", обратившись к нему по индексу, то есть по его порядковому номеру в векторе:
vec
vec[1]
vec[2]
vec[c(1,2)]
# Есть специальная команда, которая создаёт вектор целых чисел от A до B:
1:3
1:100 #ну, вы поняли

vec[1:3]

# Ещё можно "достать" определённые элементы вектора с помощью вектора такой же длины, но с логическими переменными:
length(vec)
tf <- c(TRUE, TRUE, FALSE, FALSE, TRUE, TRUE) #принимаются догадки, какие элементы мы увидим

vec[tf]

# Что, если логический вектор короче?

tf <- c(TRUE, FALSE, TRUE)
vec[tf]

# Как с помощью этого прекрасного нового знания получить, скажем, все чётные или нечётные элементы вектора?

vec[c(TRUE, FALSE)]

#Операции сравнения возвращают тру-фолсы, а их можно использовать, чтобы выбирать элементы вектора. К чему я клоню?

vec <- 1:10
vec > 2
vec[vec > 2]

# Задания:

# Создайте вектор всех нечётных чисел от 45 до 100, которые больше 50 или меньше 70

vec <- 45:100
vec[c(T,F) & (vec > 50 | vec < 70)]

# Возведите в квадрат все числа от 1 до 30, которые кратны трём. Для этого вам понадобится оператор, который возвращает остаток от деления:
3%%3














vec <- 1:30
vec[vec%%3 == 0]^2

# Сколько чисел от 1 до 100 кратны семи?













vec <- 1:100
sum(vec%%7 == 0)

#------CLASS TWO-----
# Самая частая структура данных в R помимо векторов это дата.фрейм - то бишь, табличка. Обычно в табличке каждая строка это один испытуемый, а каждая колонка это одна переменная.

# Дата.фрейм можно создать вручную:

df <- data.frame("ColumnName1" = vec, "ColumnName2" = vec > 1)

View(df)

# Но чаще всего, конечно, мы открываем уже существующие данные - например, если мы сделали эксперимент и собрали данные. Чтобы открыть файл, который лежит у нас где-то на компьютере, нужно указать рабочую директорию - то есть папку, в которой он лежит. Это делается с помощью команды setwd(), и это, кажется, единственная вещь, которую я советую делать графически: Session -> Set working directory -> Choose directory, или шорткатом Ctrl+Shift+H

setwd("C:/Users/Елизавета/Desktop/SS_R")

#функция dir() вернёт вам список всех файлов, которые лежат в вашей нынешней рабочей директории:
files <- dir()
filename <- files[2]
df <- read.csv(file = filename)
View(df) #Что-то не то!

df <- read.csv(file = filename, sep = ";") 
View(df) # так получше!

# Иногда ещё шалит хэдер, тогда надо указать header = TRUE

# Как ещё быстро посмотреть на ваш дата.фрейм?
head(df)
tail(df)
str(df)

# Ещё немного информации о дата.фрейме:
dim(df)
nrow(df)
ncol(df)
colnames(df)

# Каждая колонка дата.фрейма это вектор. Его можно вытащить с помощью знака доллара, $:
df$size
df$participant
# Таким же образом можно и создать новую колонку в дата.фрейме:
df$newColumn <- "meow"
df$newColumn
df$sizeDiv10 <- df$size/10
df$sizeDiv10

# Большинство функций в R принимают именно вектора. Например:
unique(df$size)
mean(df$size)

# Таким образом мы уже можем получить кучу описательных статистик о наших данных:
rts <- df$main_mouse.time
mean(rts)
var(rts)
summary(rts)
hist(rts)
quantile(rts, 0.90)

# Кроме того, элементы из дата.фрейма можно выбирать по индексам, так же, как в векторе, только с поправкой на то, что теперь у нас есть два измерения: строки и колонки
df[1,] # не забывайте про эту запятую!!
df[,1]
df[1, 1]

# Вместо индекса колонки можно использовать её имя:

df[, "participant"]

# А как получить первые десять значений в первой строке?




df[1,1:10]


# Кроме того, мы всё ещё можем использовать тру-фолсы:

df[c(T,F), ]

# А значит, мы как никогда прежде можем совать сюда операторы сравнения! Мы здесь власть!

dfOnly150 <- df[df$size == 150,]

View(dfOnly150)

# Мы можем комбинировать операторы сравнения. Например, мы хотим оставить только пробы, в которых у нас были стимулы размером 150 или 100. Какие есть два способа это сделать?





dfOnly150And100 <- df[df$size == 150 | df$size == 100, ]
dfOnly150And100 <- df[df$size %in% c(100, 150),]

# Иногда испытуемые могут кликать мимо красного кружочка - такие пробы мы хотим исключить.

unique(df$main_mouse.clicked_name)

# А сколько их?

sum(df$main_mouse.clicked_name != "main_circle")
nrow(df[df$main_mouse.clicked_name != "main_circle",])

dfOnlyCorr <- df[df$main_mouse.clicked_name == "main_circle",]
dfGABA <- df[df$participant == 'GABA',]
View(dfGABA)
sum(dfGABA$main_mouse.clicked_name != "main_circle")
# Часто мы хотим посчитать какой-нибудь показатель для каждого значения другого показателя: например, среднее время реакции для каждого размера стимула. Это можно сделать руками:

mean(dfOnlyCorr[dfOnlyCorr$size == 50, "main_mouse.time"])
mean(dfOnlyCorr[dfOnlyCorr$size == 100, "main_mouse.time"])
mean(dfOnlyCorr[dfOnlyCorr$size == 150, "main_mouse.time"])

mean(df[df$size == 50, "main_mouse.time"])
mean(df[df$size == 100, "main_mouse.time"])
mean(df[df$size == 150, "main_mouse.time"])

# Этот способ совершенно не зашкварный: работающий код лучше, чем самый эффективный на свете код. Но если вы хотите посчитать время реакции для каждого испытуемого, и у вас их двести, то сразу хочется найти способ поэффективнее, не правда ли?)) Такой способ есть в base R, но он адски неудобный, поэтому здесь единственное место, в котором я покажу вам data.table

# Что такое data.table?
#install.packages("data.table")
library(data.table)

dt <- as.data.table(df)
View(dt)

dt[1,1]
dt[1,]
dt[,1]
dt[1:3,]

#dt[i, j, by] или dt[фильтр строк, выражение, параметр]

dt[size == 150,] # i: какие нам нужны строки?
dt[size == 150, participant] # j: что с этими строками сделать. Самый простой вариант: вынуть какую-нибудь колонку
dt[size == 150, .(x_pos, participant)] # или несколько
dt[size == 150, mean(main_mouse.time)] # galaxy brain: применить функцию к колонке
dt[size == 150, .(mean(main_mouse.time), var(main_mouse.time))] # galaxy brain поболбше: или даже несколько!
dt[size == 150, newCol := 'meow'] # или добавить новую колонку
# и самый большой galaxy brain: by
dt[size == 150, mean(main_mouse.time), by = participant] # тут мы получим табличку со средним временем реакции каждого испытуемого только для стимулов с размером 150

dt[size == 150 & main_mouse.time > 0.01, .(mean(main_mouse.time), var(main_mouse.time)), by = .(participant, x_pos)]



# Задания

# Посчитайте среднее время реакции для стимулов размера 150 для первого испытуемого в дата.фрейме

# Исключите времена реакции, которые выше, чем значение 90-го перцентиля, и пробы, в которых испытуемый кликнул мимо красного кружочка. А теперь посчитайте среднее время реакции для каждого размера стимула.

# У скольки испытуемых среднее время реакции выше, чем среднее время реакции по выборке?





#------CLASS THREE-----

# Тест на нормальность: что это такое и зачем оно нужно?

# Графическая проверка
hist(rts)
hist(log(rts))
qqnorm(rts)
qqline(rts, col = "blue")
# Статистический тест
shapiro.test(rts)
# самое главное: как интерпретировать?
t.test(log(rts), mu = log(0.5))
exp(-0.6931472)
exp(-0.2647999)
exp(-0.2439298)
# Т-тесты
# Какие разновидности т-тестов вы знаете?
# Что такое зависимая или независимая выборка? У нас зависимая или независимая?
t.test(dt$main_mouse.time, mu = 0.5)
dtForTTests <- dt[, .("rt" = mean(main_mouse.time)), by = .(participant, size)]
t.test(dtForTTests[size == 100, rt], dtForTTests[size == 150, rt], paired = TRUE)
# Проверим на нормальность!
hist(dtForTTests[size == 100, rt])
hist(dtForTTests[size == 150, rt])

# Если бы были проблемы с нормальностью, мы могли бы использовать непараметрический t-тест Манна-Уитни для зависимых выборок:
wilcox.test(dtForTTests[size == 100, rt], dtForTTests[size == 150, rt], paired = TRUE)
# Ещё мы не проверили данные на равность дисперсий. Вот как это делается:
var.test(dtForTTests[size == 100, rt], dtForTTests[size == 150, rt])
# Если надо, можно уточнить, что дисперсии равны или не равны:
t.test(dtForTTests[size == 100, rt], dtForTTests[size == 150, rt], var.equal = F)
# По умолчанию R делает поправку Уэлча о том, что дисперсии не равны.

# Здесь, конечно, имеет смысл делать Анову. Для этого в Ар есть удобная библиотека Rstatix. Я не буду подробно её разбирать, но покажу, как выглядит код для нашего анализа:
install.packages("rstatix")
library(rstatix)

resAnova <- anova_test(dtForTTests, dv = rt, wid = participant, within = size)
get_anova_table(resAnova)

# И напоследок - простой график
x <- -10:10
y <- x^2
plot(x, y)
plot(x, y, type = 'p')#points
plot(x, y, type = 'l') #line
plot(x, y, type = 'b') #both points and line
plot(x, y, type = 'p', col = 'red')
plot(x, y, type = 'p', col = '#AA4371')
plot(x, y, type = 'p', col = '#AA4371', pch = 16)
?pch

plot(dtForTTests$size, dtForTTests$rt, col = dtForTTests$size, pch = 16)

library(scales)
plot(dtForTTests$size, dtForTTests$rt, col = alpha(dtForTTests$size, 0.5), pch = 16)

boxplot(dtForTTests$rt)

boxplot(rt~size, data = dtForTTests)
# интерпретация: https://miro.medium.com/max/1400/1*2c21SkzJMf3frPXPAR_gZA.png 

# Финальное задание: Начиная с загрузки датасета, сделайте всё, что нужно, чтобы построить скаттерплот со временами реакции любого одного испытуемого в датасете в зависимости от размера стимула.